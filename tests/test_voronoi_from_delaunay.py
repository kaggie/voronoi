"""
Unit tests for Voronoi diagram construction from Delaunay triangulations.

This module tests the functionality provided in `voronoi_from_delaunay.py`:
- `construct_voronoi_polygons_2d`: Construction of 2D Voronoi cells (polygons)
  from 2D Delaunay triangulations. Checks include correct identification of
  Voronoi vertices and ordering of polygon vertices for each cell.
- `construct_voronoi_polyhedra_3d`: Construction of 3D Voronoi cells (polyhedra)
  from 3D Delaunay tetrahedralizations. Tests focus on the structure of returned
  faces (lists of ordered global vertex indices) and properties of these faces,
  such as coplanarity.
- `_order_face_vertices_3d`: Helper function for ordering vertices of a 3D Voronoi face.

Tests utilize Delaunay triangulations generated by `delaunay_2d.py` and `delaunay_3d.py`
and geometric primitives/constants from `geometry_core.py`.
"""
import torch
import unittest
import math # For math.sqrt, math.pi, etc.
from collections import defaultdict # For context, not directly used in all tests here

from ..voronoi_from_delaunay import construct_voronoi_polygons_2d, construct_voronoi_polyhedra_3d, _order_face_vertices_3d
from ..circumcenter_calculations import compute_tetrahedron_circumcenter_3d # For test setup
from ..geometry_core import EPSILON, compute_polygon_area # For checking 2D ordering
from ..delaunay_2d import delaunay_triangulation_2d
from ..delaunay_3d import delaunay_triangulation_3d

class TestVoronoiFromDelaunay(unittest.TestCase):
    """
    Tests Voronoi construction functions from `voronoi_from_delaunay.py`.
    """

    # --- Helper Methods ---
    def _check_2d_polygon_ordering(self, polygon_vertices_list: list[torch.Tensor]):
        """
        Checks if a 2D polygon's vertices (list of tensors) are ordered
        approximately counter-clockwise by verifying a positive signed area.
        """
        if len(polygon_vertices_list) < 3:
            return True # Not enough vertices for an area-based ordering check.
        
        polygon_tensor = torch.stack(polygon_vertices_list)
        # Shoelace formula: Area = 0.5 * sum(x_i * y_{i+1} - x_{i+1} * y_i)
        area = 0.0
        for i in range(polygon_tensor.shape[0]):
            p1 = polygon_tensor[i]
            p2 = polygon_tensor[(i + 1) % polygon_tensor.shape[0]] # Wrap around
            area += (p1[0] * p2[1] - p2[0] * p1[1]).item()
        signed_area = 0.5 * area
        
        # For Voronoi cells ordered by atan2 around centroid, expect positive area (CCW).
        self.assertTrue(signed_area >= -EPSILON, # Allow for very small negative due to precision
                        f"Polygon has non-positive area {signed_area}, indicating CW or problematic ordering.")
        return True

    def _check_3d_face_coplanarity(self, face_vertices_coords: torch.Tensor, normal_check_atol: float = 1e-5):
        """
        Checks if all vertices of a 3D face (defined by coordinates) are coplanar.
        A face with < 4 points is considered planar by definition.
        """
        if face_vertices_coords.shape[0] < 4:
            return True 
        
        p0 = face_vertices_coords[0]
        p1 = face_vertices_coords[1]
        p2 = face_vertices_coords[2]
        
        # Calculate normal for the plane defined by the first three non-collinear points
        # (assuming the ordering function provides a reasonable first three points for a face)
        normal = torch.cross(p1 - p0, p2 - p0)
        normal_norm = torch.linalg.norm(normal)

        if normal_norm < EPSILON: # First three points are collinear
            # For a degenerate face (all points collinear), all further points must also be on that line.
            if face_vertices_coords.shape[0] > 2:
                line_vec = p1 - p0
                line_vec_norm = torch.linalg.norm(line_vec)
                if line_vec_norm < EPSILON : return True # All points are coincident (coplanar)
                line_vec = line_vec / line_vec_norm
                for i in range(3, face_vertices_coords.shape[0]):
                    pt_vec = face_vertices_coords[i] - p0
                    # Distance from point to line: ||cross(pt_vec, line_vec)||
                    dist_from_line_sq = torch.sum(torch.cross(pt_vec, line_vec)**2)
                    self.assertTrue(dist_from_line_sq < EPSILON**2, 
                                    f"Vertices of a degenerate face are not all collinear. Face:\n{face_vertices_coords}")
            return True # Collinear points are coplanar.

        normal = normal / normal_norm

        # Check if all other points lie on this plane: dot(normal, point - p0) should be close to 0.
        for i in range(3, face_vertices_coords.shape[0]):
            dist_from_plane = torch.dot(normal, face_vertices_coords[i] - p0)
            self.assertTrue(torch.abs(dist_from_plane) < normal_check_atol, 
                            f"Face not coplanar. Point {i} (val {face_vertices_coords[i]}) dist from plane: {dist_from_plane}. Face:\n{face_vertices_coords}")
        return True

    # --- 2D Voronoi Tests ---
    def test_construct_voronoi_2d_simple_triangle(self):
        """Tests 2D Voronoi for 3 points forming a triangle."""
        points = torch.tensor([[0.,0.],[2.,0.],[0.,2.]], dtype=torch.float32) 
        delaunay_tris = delaunay_triangulation_2d(points) 
        self.assertEqual(delaunay_tris.shape[0], 1, "Input triangle should form 1 Delaunay triangle.")
        
        cells, v_vertices = construct_voronoi_polygons_2d(points, delaunay_tris)
        
        self.assertEqual(v_vertices.shape[0], 1, "Expected 1 unique Voronoi vertex (the circumcenter).") 
        expected_circumcenter = torch.tensor([1.0, 1.0])
        self.assertTrue(torch.allclose(v_vertices[0], expected_circumcenter))
        self.assertEqual(len(cells), 3, "Expected 3 Voronoi cells.")
        for i in range(3): 
            self.assertEqual(len(cells[i]), 1, f"Cell {i} should be defined by 1 Voronoi vertex (unbounded cell).")
            if cells[i]:
                self.assertTrue(torch.allclose(cells[i][0], expected_circumcenter))

    def test_construct_voronoi_2d_square(self):
        """Tests 2D Voronoi for 4 points forming a square."""
        points = torch.tensor([[0.,0.],[1.,0.],[1.,1.],[0.,1.]], dtype=torch.float32)
        delaunay_tris = delaunay_triangulation_2d(points)
        self.assertEqual(delaunay_tris.shape[0], 2, "Square should form 2 Delaunay triangles.")
        
        cells, v_vertices = construct_voronoi_polygons_2d(points, delaunay_tris)
        
        self.assertEqual(v_vertices.shape[0], 1, "Square's Voronoi diagram should have 1 unique vertex at center.")
        if v_vertices.shape[0] == 1:
            self.assertTrue(torch.allclose(v_vertices[0], torch.tensor([0.5,0.5])))
        
        self.assertEqual(len(cells), 4, "Expected 4 Voronoi cells for a square.") 
        for i in range(4):
            # Each cell for a square's vertex is formed by the single central Voronoi vertex.
            # The actual cell is unbounded, defined by rays from this vertex.
            self.assertEqual(len(cells[i]), 1, f"Cell {i} for square vertex should be associated with 1 Voronoi vertex.")
            if cells[i]:
                 self.assertTrue(torch.allclose(cells[i][0], torch.tensor([0.5,0.5])))

    def test_construct_voronoi_2d_line_points(self):
        """Tests 2D Voronoi for collinear points (expects no Voronoi vertices/polygons)."""
        for num_pts in [3, 4, 5]:
            points = torch.tensor([[float(i), 0.] for i in range(num_pts)], dtype=torch.float32)
            delaunay_tris = delaunay_triangulation_2d(points)
            self.assertEqual(delaunay_tris.shape[0], 0, f"{num_pts} collinear points should yield 0 Delaunay triangles.")
            
            cells, v_vertices = construct_voronoi_polygons_2d(points, delaunay_tris)
            self.assertEqual(v_vertices.shape[0], 0, "Expected 0 Voronoi vertices for collinear input.")
            self.assertEqual(len(cells), num_pts, "Should return one (empty) cell list per input point.")
            for i in range(num_pts):
                self.assertEqual(len(cells[i]), 0, f"Cell {i} for collinear points should be empty.")

    def test_construct_voronoi_2d_unbounded_regions_convex_quad(self):
        """Tests 2D Voronoi for a convex quadrilateral, where all cells are unbounded."""
        points = torch.tensor([[0.,0.],[2.,1.],[1.,3.],[ -1.,2.]], dtype=torch.float32) 
        delaunay_tris = delaunay_triangulation_2d(points) 
        self.assertEqual(delaunay_tris.shape[0], 2, "Convex quad should form 2 Delaunay triangles.")

        cells, v_vertices = construct_voronoi_polygons_2d(points, delaunay_tris)
        # Expect 2 unique Voronoi vertices (circumcenters of the 2 Delaunay triangles)
        self.assertEqual(v_vertices.shape[0], 2, "Expected 2 unique Voronoi vertices.")
        self.assertEqual(len(cells), 4, "Expected 4 Voronoi cells.")
        for i in range(4):
            # Each cell for a convex hull point is unbounded, formed by the 2 Voronoi vertices and extends to infinity.
            self.assertEqual(len(cells[i]), 2, f"Cell {i} should be defined by 2 Voronoi vertices.")
            if len(cells[i]) == 2: # Minimal check for ordering for 2 points is not meaningful with Shoelace.
                pass # self._check_2d_polygon_ordering(cells[i]) # Ordering check is for >=3 points

    # --- 3D Voronoi Tests ---
    def test_order_face_vertices_3d_simple_face(self):
        """Tests the internal helper `_order_face_vertices_3d` for a simple square face."""
        edge_A = torch.tensor([0.,0.,-1.])
        edge_B = torch.tensor([0.,0.,1.])
        face_v_coords_unord = torch.tensor([
            [1.,0.,0.], [0.,1.,0.], [-1.,0.,0.], [0.,-1.,0.] 
        ], dtype=torch.float32)
        perm = torch.randperm(4) # Shuffle to test ordering
        face_v_coords_shuffled = face_v_coords_unord[perm]
        
        ordered_coords, ordered_indices = _order_face_vertices_3d(face_v_coords_shuffled, edge_A, edge_B)
        
        self.assertEqual(ordered_coords.shape, face_v_coords_shuffled.shape, "Ordered coords shape mismatch.")
        # Check if all original vertices are present (sum check is a proxy, unique set is better)
        sum_original = torch.sum(face_v_coords_unord, dim=0)
        sum_ordered = torch.sum(ordered_coords, dim=0)
        self.assertTrue(torch.allclose(sum_original, sum_ordered), "Sum of ordered and unordered coords differ.")
        self.assertEqual(len(torch.unique(ordered_coords, dim=0)), 4, "Ordered vertices should be unique and all present.")


        if ordered_coords.shape[0] >= 3:
            self.assertTrue(self._check_3d_face_coplanarity(ordered_coords), "Ordered face vertices are not coplanar.")
            # Check alignment of face normal with dual Delaunay edge
            v1 = ordered_coords[1] - ordered_coords[0]
            v2 = ordered_coords[2] - ordered_coords[0]
            face_normal = torch.cross(v1, v2)
            face_normal_norm = torch.linalg.norm(face_normal)
            if face_normal_norm > EPSILON:
                face_normal = face_normal / face_normal_norm
                edge_vec = edge_B - edge_A
                edge_vec_norm = torch.linalg.norm(edge_vec)
                if edge_vec_norm > EPSILON:
                    edge_vec = edge_vec / edge_vec_norm
                    self.assertTrue(torch.allclose(torch.abs(torch.dot(face_normal, edge_vec)), torch.tensor(1.0), atol=1e-5),
                                    "Face normal not aligned with dual Delaunay edge.")

    def test_construct_voronoi_3d_single_tetrahedron(self):
        """Tests 3D Voronoi for a single Delaunay tetrahedron; expects no polygonal faces."""
        points = torch.tensor([[0.,0.,0.],[1.,0.,0.],[0.,1.,0.],[0.,0.,1.]], dtype=torch.float32)
        delaunay_tets = delaunay_triangulation_3d(points) 
        self.assertEqual(delaunay_tets.shape[0], 1, "Expected 1 Delaunay tetrahedron.")
        
        cells_faces, v_vertices = construct_voronoi_polyhedra_3d(points, delaunay_tets)

        self.assertEqual(v_vertices.shape[0], 1, "Expected 1 unique Voronoi vertex (circumcenter).")
        expected_cc = torch.tensor([0.5,0.5,0.5])
        if v_vertices.shape[0] == 1:
            self.assertTrue(torch.allclose(v_vertices[0], expected_cc))
        
        self.assertEqual(len(cells_faces), 4, "Expected 4 Voronoi cells (one for each input point).")
        for i in range(4):
            # For a single Delaunay tet, all Voronoi "faces" are just rays/edges from the single Voronoi vertex.
            # The code filters out faces with < 3 vertices.
            self.assertEqual(len(cells_faces[i]), 0, f"Cell {i} should have 0 polygonal (>=3 verts) faces.")

    def test_construct_voronoi_3d_center_point_tetrahedron(self):
        """Tests 3D Voronoi for a central point inside a tetrahedron."""
        points = torch.tensor([
            [2.,0.,0.], [-1.,1.732,0.], [-1.,-1.732,0.], [0.,0.,2.5], # Outer tet (indices 0-3)
            [0.,0.,0.25] # Inner point (index 4)
        ], dtype=torch.float32)
        delaunay_tets = delaunay_triangulation_3d(points) 
        # Expected Delaunay: 4 tetrahedra, each formed by the inner point and one face of the outer tet.
        self.assertEqual(delaunay_tets.shape[0], 4, "Expected 4 Delaunay tetrahedra.")
        
        cells_faces, v_vertices = construct_voronoi_polyhedra_3d(points, delaunay_tets)
        # Expected Voronoi vertices: circumcenters of these 4 tetrahedra.
        self.assertEqual(v_vertices.shape[0], 4, "Expected 4 unique Voronoi vertices.")
        
        # Test the Voronoi cell for the central point (index 4)
        central_cell_faces = cells_faces[4] 
        # This cell should be a closed polyhedron (a tetrahedron itself).
        # Its faces are dual to the Delaunay edges connecting the central point to outer points. (4 edges)
        self.assertEqual(len(central_cell_faces), 4, "Central Voronoi cell should have 4 faces.")
        for face_indices in central_cell_faces:
            # Each face is dual to an edge like (P_center, P_outer_i).
            # This edge is shared by 3 Delaunay tetrahedra.
            # So, each face of the central Voronoi cell should be a triangle.
            self.assertEqual(len(face_indices), 3, "Each face of the central cell should be a triangle (3 vertices).")
            self.assertEqual(len(set(face_indices)), 3, "Face has duplicate vertex indices.")
            face_coords = v_vertices[torch.tensor(face_indices, dtype=torch.long)]
            self.assertTrue(self._check_3d_face_coplanarity(face_coords))

    # More tests for 3D cube, coplanar/collinear inputs for construct_voronoi_polyhedra_3d can be added
    # similar to tests/test_delaunay_3d.py if more detailed Voronoi structure is asserted.

if __name__ == '__main__':
    unittest.main(argv=['first-arg-is-ignored'], exit=False)
